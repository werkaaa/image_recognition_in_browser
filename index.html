<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>airplanes vs onions</title>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"> </script>

<div id="app">
    <div class="note">{{Status}}</div>

    <div class="canvas-container">
        <canvas id="input-canvas"
                width="140"
                height="140"
                @mousemove="draw"
        />
    </div>

    <button id="clear_value" @click="clear">Clear</button>
    <button id="show_pixels" @click="show">Show</button>
    <button id="inference" @click="inference">Inference</button>

    <div class="ans">{{Answer}}</div>

</div>


<script>
    class Predictor {

        constructor() {
            this.model = null;
        }

        async load(model_url) {
            try {
                // this.model = await loadFrozenModel(model_url, weights_url);
                this.model = await tf.loadModel(model_url)
            } catch (e) {
                console.log(e);
            }
        }

        async predict(pixels) {
            return tf.tidy(() => {
                const xs = tf.tensor2d([pixels]);
                return this.model.execute({x: xs})
            }).dataSync();
        }
    }

    const MODEL_URL = 'model/model.json';

    const HEIGHT = 28;
    const WIDTH = 28;
    const pixels = [];

    for (let i = 0; i < HEIGHT * WIDTH; i++) {
        pixels[i] = 0;
    }

    const preds = [];
    for (let i = 0; i < 2; i++) {
        preds[i] = 0;
    }

    var app = new Vue({
        el: '#app',
        data: {
            Status: 'Hello Vue!',
            Answer: 'Draw airplane or onion',
            predictor: new Predictor()
        },
        methods: {
            draw(e) {
                if (e.buttons == 1) {
                    const ctx = document.getElementById('input-canvas').getContext('2d');
                    ctx.fillStyle = "rgb(0,0,0)";
                    ctx.fillRect(e.offsetX, e.offsetY, 8, 8);
                    const x = Math.floor(e.offsetY * 0.2);
                    const y = Math.floor(e.offsetX * 0.2) + 1;
                    for (let dy = 0; dy < 2; dy++) {
                        for (let dx = 0; dx < 2; dx++) {
                            if ((x + dx < WIDTH) && (y + dy < HEIGHT)) {
                                pixels[(y + dy) + (x + dx) * HEIGHT] = 1
                            }
                        }
                    }
                }
            },
            clear() {
                const ctx = document.getElementById('input-canvas').getContext('2d');
                ctx.fillStyle = "rgb(255,255,255)";
                ctx.fillRect(0, 0, 140, 140);
                for (var i = 0; i < 28 * 28; i++) {
                    pixels[i] = 0;
                }
                },
            show() {
                console.log(pixels)
            },
            inference() {
                self.predictor.load(MODEL_URL).then(() => {
                    console.log("Model loaded!");
                });
                console.log(MODEL_URL);
                console.log(pixels);
                self.predictor.predict(pixels).then((value) => {
                    preds;
                });
                console.log(preds);
            }
    }})
</script>

<style >
    #app {
        font-family: 'Avenir', Helvetica, Arial, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-align: left;
        color: #2c3e50;
        margin-top: 60px;
    }
    .canvas-container {
        border: solid 2px #666;
        width: 144px;
        height: 144px;
    }
    table {
    }
</style>

</body>
</html>